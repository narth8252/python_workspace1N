링크드리스트 
스택 
큐
더블링크드리스트 

수식을 전환 
트리와 트리순회 
그래프 

해쉬검색 
퀵정렬 - 속도가 빠름 

2세대                 3세대                      4세대
결과중심주의(데이터)    과정중심주의(알고리즘)        결과중심(당연히 알고리즘포함) 
스파게티 코드          모듈화(프로시저와 함수)       클래스, 객체  
goto 문              goto 문 없애기               
                     (리눅스 os 마우스제어프로그램 
                     만들때-경험담)
                     자료구조 -데이터 측면에서 바라봄 
                     알고리즘 -절차적 측명에서 바라봄      

하드웨어 -> 메모리 
부팅 -> 전원을 킨다. rom을읽어서 기본프로그램(rom bios)을 읽고 
     -> 외장하드나 ssd 또는 
       cd를 이용해서 os를 읽어들인다. 
    -> os는 ram 이라는 메모리에 둔다 
rom (read only memory) -읽기전용메모리 
ram (random access memory) - 
    sram(static ram)- 전원이 있는 동안 정보가 계속 유지된다, cache메모리 
    dram(dynamic ram) - 주기적으로 refresh 된다.
레지스터 - 연산을 담당하는 메모리
(ax, bx, cx, dx, ip-다음 명령어를 가르킴, pc)
ssd - 플래시메모리                     

변수
C언어 
      값변수         int a = 6;      a라는 변수와 값 6 전부 스택에 저장
      포인터형변수    int *p;  //값저장못함, 주소만 저장 
                    p = &a;  다른 변수의 주소를 저장하거나 
                    p = new int;  힙공간에 동적으로 할당을 받는다 
                    *p = 20;    
                    int **q; 2중포인터 
                    int ***r;
        어던 변수를 값타입으로도 선언할 수 있고 또는 포인터타입으로도 
        선언할 수 있다. 장점 : os나 그밖에 시스템 프로그램이 다 가능하다. 
자바  포인터를 없앤다. 
     값타입 - 그밖에 타입들           값타입을 때로는 참조로 전환해야 할경우
                                   가 있다. wrapper클래스 
                                   int 값타입
                                   Integer 참조타입 
     참조타입(포인터) - 배열과 객체만    

파이썬  우린 전부 참조다 , 모든 값은 다 heap에 저장된다. 
a = 12          int       a -------------->   12
a = "Hello"     str       a -------------->   "Hello"
a = [1,2,3,4]   list      a -------------->  [1,2,3,4,5]
                          a -------------->  add 
파이썬의 모든 변수는 대상 자체가 아니라 대상의 주소만 저장한다. 

a = 12   불변형(immutable)

배열의 본래 특징 
1. 연속된 메모리 공간 
2. 정적이다. - 프로그램 실행전에 메모리 크기 확정, 위치 확정 
             수행도중에 메모리 크기를 늘이거나 줄이거나 또는 
             위치 이동 불가능 (파이썬, 자바도 이 성격 위배됨)
3. 인덱싱으로 요소들을 접근할 수 있다 
4. 같은 타입이어야 한다 (파이썬은 해당없음)
   a = [1, 'a', {"key1":"값1"}, [1,2,3], (3,4,5), Person()]

   a ----------> [주소1 -------> 1,
                  주소2 -------> a,
                  주소3 -------> {"key1":"값1"}
                  주소4 -------> [1,2,3]
                  주소5 -------> (3,4,5)
                  주소6 -------> Person()]      

 [3, -1, 5, 0, 7, 4, 9, 1],
 
 max1 = 3 
 max2 = -1 
 
 max1 > 5       max1=5  max=3    
 max1 > 0 max>0 
 max1 > 7       max1=7  max2=5
 max1 > 4    
 max1 > 9       max1=9  max2=7   

 [3, -1, 5, 7, 6, 4, 9, 1],
 1. max1=3 max=-1 
 2. 3번째부터 반복 
    만일 max1 < arr[2](5)  max2=max1(3)  max1=arr[2]  max1=5
    만일 max1 < arr[3](7)  max2=max1(5)  max1=arr[3]  max1=7
    만일 max1 < arr[4](6)  
        만일 max2<arr[4]   max2=arr[4](6)  max1=7
    
    
          